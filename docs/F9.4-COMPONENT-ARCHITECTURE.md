# Feature 9.4: Prompt Management Integration - Component Architecture Design

**Feature**: F9.4 - Prompt Management Integration
**Epic**: EPIC-09 - Settings Management
**Designer**: Claude Code
**Status**: Design Approved ✅
**Last Updated**: 2025-11-05

---

## Executive Summary

This document defines the component architecture for integrating the existing Prompt Management API (Epic 8, F8.1-002) into the Settings UI. The design extends the current Settings page structure with a new "Prompts" section in the AI Settings tab, enabling users to view, edit, create, and manage prompt versions through a intuitive interface.

**Key Design Principles**:
- **Consistency**: Match existing Settings patterns (SettingsCategoryPanel, SettingItem, ApiKeyInput)
- **Reusability**: Create composable components that can be used independently
- **Progressive Enhancement**: Start with list/edit, add version history in second story
- **Backend Integration**: Use existing Epic 8 Prompt API (`/api/prompts/*`)
- **User Experience**: Intuitive workflow with clear visual feedback

---

## 1. Component Hierarchy

### 1.1 Component Tree

```
SettingsPage (existing)
└── SettingsCategoryPanel (existing, modified)
    ├── SettingItem (existing, for regular settings)
    ├── ApiKeyInput (existing, for API keys)
    └── PromptsManager (NEW - only renders in "prompts" category)
        ├── PromptsList (NEW)
        │   ├── PromptsListHeader (NEW)
        │   │   ├── Search input
        │   │   ├── Category filter dropdown
        │   │   └── "Create Prompt" button
        │   └── PromptCard[] (NEW)
        │       ├── Prompt metadata (name, category, version)
        │       ├── Preview (truncated prompt_text)
        │       └── Actions (Edit, Delete, History)
        │
        ├── PromptEditor (NEW - modal or side panel)
        │   ├── PromptEditorHeader (NEW)
        │   │   ├── Prompt name input
        │   │   ├── Category selector
        │   │   └── Close button
        │   ├── PromptEditorBody (NEW)
        │   │   ├── Template textarea (monospace, large)
        │   │   ├── Variable highlighting (visual indicators for {{var}})
        │   │   ├── Syntax hints panel
        │   │   └── Template variables manager
        │   └── PromptEditorFooter (NEW)
        │       ├── "Test Prompt" button
        │       ├── "Save" button
        │       ├── "Cancel" button
        │       └── Version indicator
        │
        └── PromptVersionHistory (NEW - modal, Story F9.4-002)
            ├── VersionHistoryHeader (NEW)
            │   ├── Prompt name
            │   ├── Close button
            │   └── Current version indicator
            ├── VersionTimeline (NEW)
            │   └── VersionTimelineItem[] (NEW)
            │       ├── Version number
            │       ├── Changed by
            │       ├── Timestamp
            │       ├── Change reason
            │       └── Actions (View, Restore, Compare)
            └── VersionDiffViewer (NEW)
                ├── Side-by-side comparison
                ├── Highlight changes
                └── "Restore This Version" button
```

### 1.2 Integration with Existing Settings Structure

**Modification to SettingsCategoryPanel.tsx**:
```typescript
// Current behavior: renders SettingItem or ApiKeyInput
// New behavior: also check for "prompts" category and render PromptsManager

if (categoryKey === 'prompts') {
  return <PromptsManager />
}

// Existing logic for regular settings continues...
```

**No changes needed to**:
- `SettingsPage.tsx` (already fetches categories, "prompts" will appear automatically)
- `SettingItem.tsx` (reusable as-is)
- `ApiKeyInput.tsx` (reusable as-is)

---

## 2. Component Specifications

### 2.1 PromptsManager Component

**Purpose**: Top-level container for prompt management within AI Settings tab
**Responsibility**: State management, API integration, routing between list/edit/history views

#### Props Interface
```typescript
// No props - standalone component
export interface PromptsManagerProps {}
```

#### State Management
```typescript
interface PromptsManagerState {
  // Data
  prompts: PromptResponse[]
  selectedPrompt: PromptResponse | null

  // UI State
  view: 'list' | 'edit' | 'history'
  loading: boolean
  error: string | null

  // Filters
  searchQuery: string
  categoryFilter: 'all' | 'global' | 'position' | 'forecast'
  activeOnly: boolean
}
```

#### API Integration Points
```typescript
// GET /api/prompts - List prompts
const fetchPrompts = async (category?: string, activeOnly: boolean = true) => {
  const response = await axios.get<PromptListResponse>(
    `${API_URL}/api/prompts`,
    { params: { category, active_only: activeOnly } }
  )
  return response.data
}

// POST /api/prompts - Create prompt
const createPrompt = async (data: PromptCreate) => {
  const response = await axios.post<PromptResponse>(
    `${API_URL}/api/prompts`,
    data
  )
  return response.data
}

// PUT /api/prompts/{id} - Update prompt
const updatePrompt = async (id: number, data: PromptUpdate) => {
  const response = await axios.put<PromptResponse>(
    `${API_URL}/api/prompts/${id}`,
    data
  )
  return response.data
}

// DELETE /api/prompts/{id} - Soft delete
const deletePrompt = async (id: number) => {
  await axios.delete(`${API_URL}/api/prompts/${id}`)
}
```

#### Key Methods
```typescript
const handleCreatePrompt = () => {
  setSelectedPrompt(null)
  setView('edit')
}

const handleEditPrompt = (prompt: PromptResponse) => {
  setSelectedPrompt(prompt)
  setView('edit')
}

const handleDeletePrompt = async (id: number) => {
  // Confirm dialog
  if (window.confirm('Are you sure?')) {
    await deletePrompt(id)
    await refetchPrompts()
  }
}

const handleViewHistory = (prompt: PromptResponse) => {
  setSelectedPrompt(prompt)
  setView('history')
}

const handleSavePrompt = async (data: PromptCreate | PromptUpdate) => {
  if (selectedPrompt) {
    await updatePrompt(selectedPrompt.id, data)
  } else {
    await createPrompt(data)
  }
  setView('list')
  await refetchPrompts()
}
```

---

### 2.2 PromptsList Component

**Purpose**: Display all prompts in a searchable, filterable list
**Responsibility**: Filtering, rendering PromptCard items

#### Props Interface
```typescript
export interface PromptsListProps {
  prompts: PromptResponse[]
  loading: boolean
  onCreatePrompt: () => void
  onEditPrompt: (prompt: PromptResponse) => void
  onDeletePrompt: (id: number) => void
  onViewHistory: (prompt: PromptResponse) => void
}
```

#### State Management
```typescript
interface PromptsListState {
  searchQuery: string
  categoryFilter: 'all' | 'global' | 'position' | 'forecast'
}
```

#### Filtering Logic
```typescript
const filteredPrompts = useMemo(() => {
  return prompts.filter(prompt => {
    // Category filter
    if (categoryFilter !== 'all' && prompt.category !== categoryFilter) {
      return false
    }

    // Search filter (name or prompt_text contains query)
    if (searchQuery) {
      const query = searchQuery.toLowerCase()
      return (
        prompt.name.toLowerCase().includes(query) ||
        prompt.prompt_text.toLowerCase().includes(query)
      )
    }

    return true
  })
}, [prompts, searchQuery, categoryFilter])
```

#### JSX Structure
```typescript
<div className="prompts-list">
  <PromptsListHeader
    onCreatePrompt={onCreatePrompt}
    searchQuery={searchQuery}
    onSearchChange={setSearchQuery}
    categoryFilter={categoryFilter}
    onCategoryChange={setCategoryFilter}
  />

  {loading ? (
    <div className="prompts-loading">
      <Loader2 className="spinner" />
      <p>Loading prompts...</p>
    </div>
  ) : filteredPrompts.length === 0 ? (
    <div className="prompts-empty">
      <p>No prompts found</p>
      <button onClick={onCreatePrompt}>Create First Prompt</button>
    </div>
  ) : (
    <div className="prompts-grid">
      {filteredPrompts.map(prompt => (
        <PromptCard
          key={prompt.id}
          prompt={prompt}
          onEdit={() => onEditPrompt(prompt)}
          onDelete={() => onDeletePrompt(prompt.id)}
          onViewHistory={() => onViewHistory(prompt)}
        />
      ))}
    </div>
  )}
</div>
```

---

### 2.3 PromptCard Component

**Purpose**: Display individual prompt summary with actions
**Responsibility**: Show metadata, truncated preview, action buttons

#### Props Interface
```typescript
export interface PromptCardProps {
  prompt: PromptResponse
  onEdit: () => void
  onDelete: () => void
  onViewHistory: () => void
}
```

#### JSX Structure
```typescript
<div className="prompt-card">
  <div className="prompt-card-header">
    <h3 className="prompt-name">{prompt.name}</h3>
    <span className={`prompt-category badge-${prompt.category}`}>
      {prompt.category}
    </span>
  </div>

  <div className="prompt-preview">
    <p>{truncate(prompt.prompt_text, 150)}</p>
  </div>

  <div className="prompt-metadata">
    <span className="prompt-version">v{prompt.version}</span>
    <span className="prompt-updated">
      {formatRelativeTime(prompt.updated_at)}
    </span>
    {!prompt.is_active && (
      <span className="prompt-inactive">Inactive</span>
    )}
  </div>

  <div className="prompt-actions">
    <button
      className="prompt-action-btn edit"
      onClick={onEdit}
      title="Edit Prompt"
    >
      <Edit2 size={16} />
      Edit
    </button>
    <button
      className="prompt-action-btn history"
      onClick={onViewHistory}
      title="View History"
    >
      <History size={16} />
      History
    </button>
    <button
      className="prompt-action-btn delete"
      onClick={onDelete}
      title="Delete Prompt"
    >
      <Trash2 size={16} />
      Delete
    </button>
  </div>
</div>
```

---

### 2.4 PromptEditor Component

**Purpose**: Create/edit prompt with template editing and variable management
**Responsibility**: Form validation, template syntax, save/cancel logic

#### Props Interface
```typescript
export interface PromptEditorProps {
  prompt: PromptResponse | null  // null = create mode
  onSave: (data: PromptCreate | PromptUpdate) => Promise<void>
  onCancel: () => void
}
```

#### State Management
```typescript
interface PromptEditorState {
  // Form data
  name: string
  category: 'global' | 'position' | 'forecast'
  promptText: string
  templateVariables: Record<string, string>  // {variable_name: type}
  changeReason: string  // For updates only

  // UI state
  saving: boolean
  testing: boolean
  testResult: string | null
  errors: Record<string, string>

  // Editor state
  cursorPosition: number
  highlightedVariables: string[]  // Variables found in template
}
```

#### Validation Logic
```typescript
const validateForm = (): boolean => {
  const newErrors: Record<string, string> = {}

  // Name validation
  if (!name.trim()) {
    newErrors.name = 'Prompt name is required'
  } else if (name.length > 100) {
    newErrors.name = 'Name must be 100 characters or less'
  }

  // Prompt text validation
  if (!promptText.trim()) {
    newErrors.promptText = 'Prompt text is required'
  } else if (promptText.length < 10) {
    newErrors.promptText = 'Prompt must be at least 10 characters'
  }

  // Category validation
  if (!['global', 'position', 'forecast'].includes(category)) {
    newErrors.category = 'Invalid category'
  }

  setErrors(newErrors)
  return Object.keys(newErrors).length === 0
}
```

#### Variable Detection
```typescript
// Detect {{variable}} placeholders in template
const detectVariables = (text: string): string[] => {
  const regex = /\{\{(\w+)\}\}/g
  const matches = [...text.matchAll(regex)]
  return [...new Set(matches.map(m => m[1]))]
}

useEffect(() => {
  const detected = detectVariables(promptText)
  setHighlightedVariables(detected)

  // Auto-add detected variables to templateVariables if not present
  const newVars = { ...templateVariables }
  detected.forEach(varName => {
    if (!(varName in newVars)) {
      newVars[varName] = 'string'  // Default type
    }
  })
  setTemplateVariables(newVars)
}, [promptText])
```

#### Test Prompt Functionality
```typescript
const handleTestPrompt = async () => {
  setTesting(true)
  setTestResult(null)

  try {
    // For now, just validate that variables are defined
    const detected = detectVariables(promptText)
    const missingVars = detected.filter(v => !(v in templateVariables))

    if (missingVars.length > 0) {
      setTestResult(`Missing variable definitions: ${missingVars.join(', ')}`)
    } else {
      setTestResult('✓ Template is valid')
      toast.success('Template is valid!')
    }
  } catch (err) {
    setTestResult(`Error: ${err.message}`)
  } finally {
    setTesting(false)
  }
}
```

#### JSX Structure
```typescript
<div className="prompt-editor-modal">
  <div className="prompt-editor-overlay" onClick={onCancel} />

  <div className="prompt-editor-panel">
    <div className="prompt-editor-header">
      <h2>{prompt ? 'Edit Prompt' : 'Create Prompt'}</h2>
      <button className="close-btn" onClick={onCancel}>
        <X size={20} />
      </button>
    </div>

    <div className="prompt-editor-body">
      {/* Name Input */}
      <div className="form-group">
        <label htmlFor="prompt-name">Prompt Name</label>
        <input
          id="prompt-name"
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="e.g., global_market_analysis"
          className={errors.name ? 'error' : ''}
        />
        {errors.name && <span className="error-text">{errors.name}</span>}
      </div>

      {/* Category Selector */}
      <div className="form-group">
        <label htmlFor="prompt-category">Category</label>
        <select
          id="prompt-category"
          value={category}
          onChange={(e) => setCategory(e.target.value as any)}
          className={errors.category ? 'error' : ''}
        >
          <option value="global">Global Analysis</option>
          <option value="position">Position Analysis</option>
          <option value="forecast">Forecast Analysis</option>
        </select>
        {errors.category && <span className="error-text">{errors.category}</span>}
      </div>

      {/* Prompt Template Textarea */}
      <div className="form-group">
        <label htmlFor="prompt-text">
          Prompt Template
          <span className="label-hint">
            Use {{`{{variable}}`}} for placeholders
          </span>
        </label>
        <textarea
          id="prompt-text"
          value={promptText}
          onChange={(e) => setPromptText(e.target.value)}
          placeholder="Enter your prompt template here..."
          className={`prompt-textarea ${errors.promptText ? 'error' : ''}`}
          rows={15}
          spellCheck={false}
        />
        {errors.promptText && <span className="error-text">{errors.promptText}</span>}

        {/* Variable Hints */}
        {highlightedVariables.length > 0 && (
          <div className="variable-hints">
            <strong>Detected Variables:</strong>
            {highlightedVariables.map(varName => (
              <span key={varName} className="variable-badge">
                {{`{{${varName}}}`}}
              </span>
            ))}
          </div>
        )}
      </div>

      {/* Template Variables Manager */}
      <div className="form-group">
        <label>Template Variables</label>
        <div className="template-variables">
          {Object.entries(templateVariables).map(([varName, varType]) => (
            <div key={varName} className="variable-row">
              <span className="variable-name">{varName}</span>
              <select
                value={varType}
                onChange={(e) => setTemplateVariables({
                  ...templateVariables,
                  [varName]: e.target.value
                })}
              >
                <option value="string">String</option>
                <option value="number">Number</option>
                <option value="decimal">Decimal</option>
                <option value="date">Date</option>
                <option value="boolean">Boolean</option>
              </select>
              <button
                onClick={() => {
                  const newVars = { ...templateVariables }
                  delete newVars[varName]
                  setTemplateVariables(newVars)
                }}
                className="remove-var-btn"
                title="Remove variable"
              >
                <X size={14} />
              </button>
            </div>
          ))}
        </div>
      </div>

      {/* Change Reason (only for updates) */}
      {prompt && (
        <div className="form-group">
          <label htmlFor="change-reason">
            Change Reason
            <span className="label-hint">(optional)</span>
          </label>
          <input
            id="change-reason"
            type="text"
            value={changeReason}
            onChange={(e) => setChangeReason(e.target.value)}
            placeholder="e.g., Improved clarity"
          />
        </div>
      )}

      {/* Test Result */}
      {testResult && (
        <div className={`test-result ${testResult.startsWith('✓') ? 'success' : 'error'}`}>
          {testResult}
        </div>
      )}
    </div>

    <div className="prompt-editor-footer">
      <div className="footer-left">
        {prompt && (
          <span className="version-indicator">
            Current version: v{prompt.version}
          </span>
        )}
      </div>

      <div className="footer-right">
        <button
          className="btn-secondary"
          onClick={handleTestPrompt}
          disabled={testing || saving}
        >
          {testing ? 'Testing...' : 'Test Template'}
        </button>

        <button
          className="btn-secondary"
          onClick={onCancel}
          disabled={saving}
        >
          Cancel
        </button>

        <button
          className="btn-primary"
          onClick={handleSave}
          disabled={saving || testing}
        >
          {saving ? 'Saving...' : 'Save Prompt'}
        </button>
      </div>
    </div>
  </div>
</div>
```

---

### 2.5 PromptVersionHistory Component (Story F9.4-002)

**Purpose**: View version history and restore previous versions
**Responsibility**: Fetch versions, display timeline, show diffs, restore

#### Props Interface
```typescript
export interface PromptVersionHistoryProps {
  prompt: PromptResponse
  onClose: () => void
  onRestore: () => void  // Callback after successful restoration
}
```

#### State Management
```typescript
interface VersionHistoryState {
  versions: PromptVersionResponse[]
  loading: boolean
  selectedVersion: PromptVersionResponse | null
  compareVersion: PromptVersionResponse | null  // For side-by-side comparison
  restoring: boolean
  error: string | null
}
```

#### API Integration
```typescript
// GET /api/prompts/{id}/versions
const fetchVersions = async (promptId: number) => {
  const response = await axios.get<PromptVersionListResponse>(
    `${API_URL}/api/prompts/${promptId}/versions`
  )
  return response.data
}

// POST /api/prompts/{id}/restore/{version}
const restoreVersion = async (
  promptId: number,
  versionNumber: number,
  changeReason?: string
) => {
  const response = await axios.post<PromptResponse>(
    `${API_URL}/api/prompts/${promptId}/restore/${versionNumber}`,
    { change_reason: changeReason }
  )
  return response.data
}
```

#### Diff Algorithm
```typescript
// Simple line-by-line diff (can use library like 'diff' in production)
interface DiffLine {
  type: 'added' | 'removed' | 'unchanged'
  content: string
  lineNumber: number
}

const computeDiff = (oldText: string, newText: string): DiffLine[] => {
  const oldLines = oldText.split('\n')
  const newLines = newText.split('\n')

  // Simple implementation - in production use a proper diff library
  // For MVP, just show side-by-side without highlighting
  return []  // TODO: Implement proper diff
}
```

#### JSX Structure
```typescript
<div className="version-history-modal">
  <div className="version-history-overlay" onClick={onClose} />

  <div className="version-history-panel">
    <div className="version-history-header">
      <h2>Version History: {prompt.name}</h2>
      <div className="current-version">
        Current: v{prompt.version}
      </div>
      <button className="close-btn" onClick={onClose}>
        <X size={20} />
      </button>
    </div>

    <div className="version-history-body">
      {loading ? (
        <div className="loading-state">
          <Loader2 className="spinner" />
          <p>Loading version history...</p>
        </div>
      ) : (
        <div className="version-layout">
          {/* Timeline on left */}
          <div className="version-timeline">
            <h3>Timeline</h3>
            {versions.length === 0 ? (
              <p className="no-versions">No version history available</p>
            ) : (
              versions.map(version => (
                <VersionTimelineItem
                  key={version.id}
                  version={version}
                  isSelected={selectedVersion?.id === version.id}
                  onClick={() => setSelectedVersion(version)}
                  onRestore={() => handleRestoreVersion(version)}
                />
              ))
            )}
          </div>

          {/* Version details/diff on right */}
          <div className="version-details">
            {selectedVersion ? (
              <div className="version-viewer">
                <h3>Version {selectedVersion.version}</h3>
                <div className="version-metadata">
                  <p>
                    <strong>Changed by:</strong> {selectedVersion.changed_by || 'system'}
                  </p>
                  <p>
                    <strong>Changed at:</strong>{' '}
                    {new Date(selectedVersion.changed_at).toLocaleString()}
                  </p>
                  {selectedVersion.change_reason && (
                    <p>
                      <strong>Reason:</strong> {selectedVersion.change_reason}
                    </p>
                  )}
                </div>

                <div className="version-content">
                  <h4>Prompt Text</h4>
                  <pre className="prompt-text-viewer">
                    {selectedVersion.prompt_text}
                  </pre>
                </div>

                <div className="version-actions">
                  <button
                    className="btn-primary"
                    onClick={() => handleRestoreVersion(selectedVersion)}
                    disabled={restoring}
                  >
                    {restoring ? 'Restoring...' : 'Restore This Version'}
                  </button>

                  {/* Future: Compare button */}
                  {/* <button className="btn-secondary">
                    Compare with Current
                  </button> */}
                </div>
              </div>
            ) : (
              <div className="no-selection">
                <p>Select a version from the timeline to view details</p>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  </div>
</div>
```

---

### 2.6 Supporting Components

#### PromptsListHeader
```typescript
export interface PromptsListHeaderProps {
  onCreatePrompt: () => void
  searchQuery: string
  onSearchChange: (query: string) => void
  categoryFilter: 'all' | 'global' | 'position' | 'forecast'
  onCategoryChange: (category: string) => void
}
```

#### VersionTimelineItem
```typescript
export interface VersionTimelineItemProps {
  version: PromptVersionResponse
  isSelected: boolean
  onClick: () => void
  onRestore: () => void
}
```

---

## 3. User Experience Flows

### 3.1 Flow: View All Prompts

```
1. User navigates to Settings page
2. User clicks "AI Settings" tab
3. Settings page loads categories from backend
4. SettingsCategoryPanel detects category === "prompts"
5. SettingsCategoryPanel renders <PromptsManager />
6. PromptsManager fetches prompts from /api/prompts
7. PromptsList displays all prompts in grid layout
8. User sees:
   - Search bar
   - Category filter dropdown
   - "Create Prompt" button
   - Grid of PromptCard components
```

**Loading States**:
- Show spinner while fetching prompts
- Disable actions during loading

**Error Handling**:
- Show error message if API call fails
- Provide "Retry" button

---

### 3.2 Flow: Edit Existing Prompt

```
1. User clicks "Edit" on a PromptCard
2. PromptsManager sets selectedPrompt and view='edit'
3. PromptEditor modal appears with:
   - Pre-filled name, category, promptText
   - Pre-filled templateVariables
   - Version indicator showing current version
4. User modifies prompt text
5. Editor automatically detects {{variables}} and highlights them
6. User clicks "Test Template"
   - Editor validates variable definitions
   - Shows success/error feedback
7. User optionally adds change reason
8. User clicks "Save"
   - PUT /api/prompts/{id} with updated data
   - Modal closes on success
   - PromptsList refreshes
   - Toast notification confirms save
```

**Validation**:
- Name required, max 100 chars
- Prompt text required, min 10 chars
- Category must be valid enum value
- All detected variables must have type definitions

**Error Handling**:
- Show inline validation errors
- Show API error messages
- Prevent save if validation fails

---

### 3.3 Flow: Create New Prompt

```
1. User clicks "Create Prompt" button
2. PromptsManager sets selectedPrompt=null and view='edit'
3. PromptEditor modal appears with empty form
4. User fills in:
   - Prompt name
   - Category (dropdown)
   - Prompt text
5. Editor detects variables as user types
6. Editor auto-populates templateVariables with defaults
7. User adjusts variable types as needed
8. User clicks "Test Template"
9. User clicks "Save"
   - POST /api/prompts with new prompt data
   - Modal closes on success
   - PromptsList refreshes
   - Toast notification confirms creation
```

---

### 3.4 Flow: View Version History (Story F9.4-002)

```
1. User clicks "History" on a PromptCard
2. PromptsManager sets selectedPrompt and view='history'
3. PromptVersionHistory modal appears
4. Component fetches GET /api/prompts/{id}/versions
5. Timeline displays all versions in chronological order
6. User clicks on a version in timeline
7. Right panel shows:
   - Version number
   - Changed by
   - Changed at
   - Change reason
   - Full prompt text from that version
8. User can:
   - View different versions by clicking timeline
   - Click "Restore This Version"
```

---

### 3.5 Flow: Restore Previous Version

```
1. User is viewing version history
2. User selects a historical version
3. User clicks "Restore This Version"
4. Confirmation dialog appears:
   "Restore to version X? This will create a new version with the old content."
5. User confirms
6. POST /api/prompts/{id}/restore/{version}
   - Backend creates new version with old content
   - Backend increments version number
7. Modal shows success message
8. Version history refreshes
9. User clicks "Close" to return to list
10. PromptsList shows updated version number
```

---

## 4. State Management Strategy

### 4.1 Local Component State vs Context

**Decision**: Use **local state** for Feature 9.4

**Rationale**:
- Prompts are only used within Settings page
- No need for global access (unlike API keys or theme settings)
- Simpler implementation and testing
- Future: If prompts need to be accessed elsewhere, create `PromptsContext`

**State Locations**:
```
PromptsManager (container)
├── Prompts data (fetched from API)
├── Selected prompt (for edit/history)
├── Current view (list/edit/history)
└── Loading/error states

PromptsList (presentation)
├── Search query (local filter)
└── Category filter (local filter)

PromptEditor (form)
├── Form field values (controlled inputs)
├── Validation errors
└── Test result

PromptVersionHistory (data display)
├── Versions array (fetched from API)
├── Selected version (for viewing)
└── Loading/error states
```

---

### 4.2 Data Flow

```
API ──(fetch)──> PromptsManager ──(props)──> PromptsList ──(render)──> PromptCard
                      │                                                      │
                      │                                          (onEdit callback)
                      │                                                      │
                      └──(sets state)──< PromptEditor <─────────────────────┘
                               │
                        (onSave callback)
                               │
                               ├──(POST/PUT)──> API
                               └──(refetch)────> API
```

**Key Principle**: **Unidirectional data flow**
- Props down (data flows from parent to child)
- Events up (child calls parent callbacks)
- API calls only in PromptsManager (single source of truth)

---

## 5. API Integration Patterns

### 5.1 Backend API Summary (Epic 8 F8.1-002)

**Base URL**: `/api/prompts`

| Endpoint | Method | Purpose | Request | Response |
|----------|--------|---------|---------|----------|
| `/api/prompts` | GET | List prompts | `?category=&active_only=` | `PromptListResponse` |
| `/api/prompts/{id}` | GET | Get by ID | - | `PromptResponse` |
| `/api/prompts/name/{name}` | GET | Get by name | - | `PromptResponse` |
| `/api/prompts` | POST | Create | `PromptCreate` | `PromptResponse` |
| `/api/prompts/{id}` | PUT | Update | `PromptUpdate` | `PromptResponse` |
| `/api/prompts/{id}` | DELETE | Soft delete | - | `SuccessResponse` |
| `/api/prompts/{id}/versions` | GET | Version history | - | `PromptVersionListResponse` |
| `/api/prompts/{id}/restore/{version}` | POST | Restore version | `RestoreVersionRequest` | `PromptResponse` |

---

### 5.2 TypeScript Types (from Backend Schemas)

```typescript
// Request/Response types matching backend prompt_schemas.py

export interface PromptCreate {
  name: string                          // min 1, max 100 chars
  category: 'global' | 'position' | 'forecast'
  prompt_text: string                   // min 10 chars
  template_variables: Record<string, string>  // {varName: type}
}

export interface PromptUpdate {
  name?: string
  category?: 'global' | 'position' | 'forecast'
  prompt_text?: string
  template_variables?: Record<string, string>
  change_reason?: string                // max 500 chars
}

export interface PromptResponse {
  id: number
  name: string
  category: 'global' | 'position' | 'forecast'
  prompt_text: string
  template_variables: Record<string, string>
  version: number
  is_active: boolean
  created_at: string                    // ISO datetime
  updated_at: string                    // ISO datetime
}

export interface PromptListResponse {
  prompts: PromptResponse[]
  total: number
  skip: number
  limit: number
}

export interface PromptVersionResponse {
  id: number
  prompt_id: number
  version: number
  prompt_text: string
  changed_by: string | null
  changed_at: string                    // ISO datetime
  change_reason: string | null
}

export interface PromptVersionListResponse {
  versions: PromptVersionResponse[]
  total: number
}

export interface RestoreVersionRequest {
  change_reason?: string
}

export interface SuccessResponse {
  message: string
  success: boolean
}
```

---

### 5.3 API Client Service Pattern

**Create**: `/frontend/src/services/promptService.ts`

```typescript
import axios from 'axios'
import { API_CONFIG } from '../config/app.config'

const API_URL = API_CONFIG.BASE_URL

export const promptService = {
  // List prompts
  async listPrompts(
    category?: string,
    activeOnly: boolean = true,
    skip: number = 0,
    limit: number = 100
  ): Promise<PromptListResponse> {
    const response = await axios.get<PromptListResponse>(
      `${API_URL}/api/prompts`,
      {
        params: { category, active_only: activeOnly, skip, limit }
      }
    )
    return response.data
  },

  // Get prompt by ID
  async getPrompt(id: number): Promise<PromptResponse> {
    const response = await axios.get<PromptResponse>(
      `${API_URL}/api/prompts/${id}`
    )
    return response.data
  },

  // Create prompt
  async createPrompt(data: PromptCreate): Promise<PromptResponse> {
    const response = await axios.post<PromptResponse>(
      `${API_URL}/api/prompts`,
      data
    )
    return response.data
  },

  // Update prompt
  async updatePrompt(id: number, data: PromptUpdate): Promise<PromptResponse> {
    const response = await axios.put<PromptResponse>(
      `${API_URL}/api/prompts/${id}`,
      data
    )
    return response.data
  },

  // Delete prompt (soft delete)
  async deletePrompt(id: number): Promise<SuccessResponse> {
    const response = await axios.delete<SuccessResponse>(
      `${API_URL}/api/prompts/${id}`
    )
    return response.data
  },

  // Get version history
  async getVersionHistory(promptId: number): Promise<PromptVersionListResponse> {
    const response = await axios.get<PromptVersionListResponse>(
      `${API_URL}/api/prompts/${promptId}/versions`
    )
    return response.data
  },

  // Restore version
  async restoreVersion(
    promptId: number,
    versionNumber: number,
    changeReason?: string
  ): Promise<PromptResponse> {
    const response = await axios.post<PromptResponse>(
      `${API_URL}/api/prompts/${promptId}/restore/${versionNumber}`,
      { change_reason: changeReason }
    )
    return response.data
  }
}
```

**Usage in PromptsManager**:
```typescript
import { promptService } from '../services/promptService'

const fetchPrompts = async () => {
  try {
    setLoading(true)
    const data = await promptService.listPrompts(categoryFilter, true)
    setPrompts(data.prompts)
  } catch (err) {
    setError('Failed to load prompts')
  } finally {
    setLoading(false)
  }
}
```

---

## 6. Error Handling Strategy

### 6.1 Error Categories

| Category | Example | User-Facing Message | Recovery Action |
|----------|---------|---------------------|-----------------|
| Network Error | Axios timeout | "Unable to connect. Check your internet." | Retry button |
| Validation Error | Empty name | "Prompt name is required" | Inline error, block save |
| Not Found | Prompt deleted | "Prompt not found" | Close editor, refresh list |
| Permission Error | 403 Forbidden | "You don't have permission" | Contact admin message |
| Server Error | 500 Internal | "Server error. Please try again." | Retry button |
| Conflict | Duplicate name | "Prompt name already exists" | Change name, retry |

---

### 6.2 Error Handling Implementation

**Axios Interceptor** (optional, for global handling):
```typescript
// In promptService.ts
axios.interceptors.response.use(
  response => response,
  error => {
    if (error.response) {
      // Server responded with error
      const { status, data } = error.response

      if (status === 404) {
        throw new Error('Resource not found')
      } else if (status === 400) {
        throw new Error(data.detail || 'Invalid request')
      } else if (status === 500) {
        throw new Error('Server error. Please try again.')
      }
    } else if (error.request) {
      // No response received
      throw new Error('Network error. Check your connection.')
    }

    throw error
  }
)
```

**Component Error Handling**:
```typescript
const handleSavePrompt = async () => {
  try {
    setSaving(true)
    setError(null)

    // Validate form
    if (!validateForm()) {
      setSaving(false)
      return
    }

    // Call API
    if (selectedPrompt) {
      await promptService.updatePrompt(selectedPrompt.id, {
        name,
        category,
        prompt_text: promptText,
        template_variables: templateVariables,
        change_reason: changeReason
      })
    } else {
      await promptService.createPrompt({
        name,
        category,
        prompt_text: promptText,
        template_variables: templateVariables
      })
    }

    toast.success('Prompt saved successfully!')
    onSave()  // Close editor, refresh list
  } catch (err: any) {
    console.error('Failed to save prompt:', err)

    // Show user-friendly error
    const message = err.message || 'Failed to save prompt'
    setError(message)
    toast.error(message)
  } finally {
    setSaving(false)
  }
}
```

---

### 6.3 Validation Error Display

**Inline Errors** (next to input):
```typescript
{errors.name && (
  <span className="error-text" role="alert">
    {errors.name}
  </span>
)}
```

**Banner Errors** (top of form):
```typescript
{error && (
  <div className="error-banner" role="alert">
    <AlertCircle size={20} />
    <span>{error}</span>
    <button onClick={() => setError(null)}>
      <X size={16} />
    </button>
  </div>
)}
```

---

## 7. Edge Cases & Special Scenarios

### 7.1 Concurrent Edits

**Scenario**: Two users edit the same prompt simultaneously

**Solution** (for now):
- Last write wins (backend default)
- Future: Add optimistic locking with version checking

**Implementation**:
```typescript
// Future enhancement: Check version before update
const handleSavePrompt = async () => {
  // Before saving, refetch current prompt to check version
  const current = await promptService.getPrompt(selectedPrompt.id)

  if (current.version !== selectedPrompt.version) {
    // Version changed - someone else edited
    setError('This prompt was updated by someone else. Please refresh.')
    return
  }

  // Proceed with save...
}
```

---

### 7.2 Empty States

**Scenario 1**: No prompts exist
```typescript
<div className="prompts-empty">
  <FileText size={48} className="empty-icon" />
  <h3>No Prompts Yet</h3>
  <p>Create your first prompt to customize AI analysis output</p>
  <button onClick={onCreatePrompt} className="btn-primary">
    Create First Prompt
  </button>
</div>
```

**Scenario 2**: Search returns no results
```typescript
<div className="prompts-empty">
  <Search size={48} className="empty-icon" />
  <h3>No Results Found</h3>
  <p>Try a different search or filter</p>
  <button onClick={clearFilters} className="btn-secondary">
    Clear Filters
  </button>
</div>
```

**Scenario 3**: No version history
```typescript
<div className="no-versions">
  <History size={32} className="empty-icon" />
  <p>No version history available for this prompt</p>
</div>
```

---

### 7.3 Soft Delete Handling

**Backend Behavior**:
- DELETE /api/prompts/{id} sets `is_active=false`
- Prompt still exists in database
- Not shown in default list (active_only=true)

**UI Handling**:
1. Show confirmation dialog before delete
2. After delete, remove from list immediately (optimistic update)
3. Show success toast
4. If delete fails, restore to list and show error

```typescript
const handleDeletePrompt = async (id: number) => {
  // Confirm
  if (!window.confirm('Deactivate this prompt? It can be restored later.')) {
    return
  }

  // Optimistically remove from UI
  const backup = [...prompts]
  setPrompts(prompts.filter(p => p.id !== id))

  try {
    await promptService.deletePrompt(id)
    toast.success('Prompt deactivated')
  } catch (err) {
    // Restore on error
    setPrompts(backup)
    toast.error('Failed to deactivate prompt')
  }
}
```

---

### 7.4 Large Template Text Handling

**Scenario**: Prompt text is very long (>5000 characters)

**UI Solutions**:
1. **Editor**: Textarea with scroll (no height limit)
2. **Card Preview**: Truncate with "..." and character count
3. **Version History**: Show full text with scroll

```typescript
const truncateText = (text: string, maxLength: number = 150) => {
  if (text.length <= maxLength) return text
  return text.slice(0, maxLength) + '...'
}

// In PromptCard
<p className="prompt-preview">
  {truncateText(prompt.prompt_text, 150)}
  {prompt.prompt_text.length > 150 && (
    <span className="char-count">
      ({prompt.prompt_text.length} characters)
    </span>
  )}
</p>
```

---

### 7.5 Variable Type Mismatch

**Scenario**: User declares variable as "number" but template uses it as string

**Solution** (for MVP):
- Variable types are advisory only
- Backend stores them but doesn't enforce
- Future: Add runtime validation when prompt is used

**UI Handling**:
- Provide type dropdown (string, number, decimal, date, boolean)
- Show warning if type changes after creation
- No blocking validation

---

## 8. Testing Strategy

### 8.1 Unit Tests (Story F9.4-001)

**Required Coverage**: 85% minimum (per TDD requirement)

**PromptsManager.test.tsx**:
```typescript
describe('PromptsManager', () => {
  test('fetches and displays prompts on mount', async () => {
    // Mock API call
    // Render component
    // Wait for loading to finish
    // Assert prompts are displayed
  })

  test('filters prompts by category', async () => {
    // Render with multiple prompts
    // Change category filter
    // Assert filtered list
  })

  test('searches prompts by name', async () => {
    // Render with multiple prompts
    // Enter search query
    // Assert filtered list
  })

  test('opens editor when create button clicked', () => {
    // Render
    // Click create button
    // Assert editor is visible
  })

  test('handles API error gracefully', async () => {
    // Mock API to throw error
    // Render
    // Assert error message shown
    // Assert retry button present
  })
})
```

**PromptEditor.test.tsx**:
```typescript
describe('PromptEditor', () => {
  test('validates required fields', () => {
    // Render editor
    // Click save without filling form
    // Assert validation errors shown
  })

  test('detects variables in template', () => {
    // Render editor
    // Type template with {{variable}}
    // Assert variable highlighted
  })

  test('auto-populates template variables', () => {
    // Render editor
    // Type {{symbol}} in template
    // Assert templateVariables includes 'symbol'
  })

  test('calls onSave with correct data', async () => {
    // Render editor
    // Fill form
    // Click save
    // Assert onSave called with correct payload
  })

  test('prevents save while validation fails', () => {
    // Render editor
    // Enter invalid data
    // Assert save button disabled
  })
})
```

**PromptVersionHistory.test.tsx** (Story F9.4-002):
```typescript
describe('PromptVersionHistory', () => {
  test('fetches and displays version history', async () => {
    // Mock API call
    // Render component
    // Assert versions displayed
  })

  test('shows version details when selected', () => {
    // Render with versions
    // Click timeline item
    // Assert details panel shows version info
  })

  test('restores version on confirmation', async () => {
    // Render with versions
    // Select version
    // Click restore
    // Confirm dialog
    // Assert API called
  })

  test('handles empty version history', () => {
    // Mock empty array
    // Render
    // Assert empty state shown
  })
})
```

---

### 8.2 Integration Tests

**Test Scenarios**:
1. **End-to-End Create Flow**:
   - Navigate to Settings > AI Settings
   - Click "Create Prompt"
   - Fill form and save
   - Assert prompt appears in list

2. **Edit and Version History**:
   - Edit existing prompt
   - View version history
   - Assert new version created
   - Restore old version
   - Assert version restored

3. **Search and Filter**:
   - Create multiple prompts with different categories
   - Test search functionality
   - Test category filter
   - Assert correct filtering

---

### 8.3 Manual Testing Checklist

**Before PR**:
- [ ] Create prompt works
- [ ] Edit prompt works
- [ ] Delete prompt works
- [ ] Search prompts works
- [ ] Filter by category works
- [ ] Variable detection works
- [ ] Template variables can be edited
- [ ] Test template validates correctly
- [ ] Version history displays correctly
- [ ] Restore version works
- [ ] All error states display correctly
- [ ] Loading states show spinners
- [ ] Toast notifications appear
- [ ] Modal can be closed with X or Cancel
- [ ] Form validation prevents invalid saves
- [ ] Responsive layout works on mobile

---

## 9. Styling & CSS Architecture

### 9.1 CSS Modules Pattern

**Follow existing pattern**:
- Each component has corresponding `.css` file
- Use semantic class names (BEM-like)
- Match existing Settings components styling

**Example**: `PromptsManager.css`
```css
.prompts-manager {
  width: 100%;
  padding: 1.5rem;
}

.prompts-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
}

.prompts-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
  gap: 1.5rem;
}

@media (max-width: 768px) {
  .prompts-grid {
    grid-template-columns: 1fr;
  }
}
```

---

### 9.2 Design Tokens (match existing Settings)

**Colors**:
```css
:root {
  --color-primary: #3b82f6;       /* Blue for buttons */
  --color-success: #10b981;       /* Green for success states */
  --color-danger: #ef4444;        /* Red for delete/errors */
  --color-warning: #f59e0b;       /* Orange for warnings */

  --color-bg: #ffffff;            /* Main background */
  --color-bg-secondary: #f3f4f6;  /* Cards, panels */
  --color-border: #e5e7eb;        /* Borders */

  --color-text: #111827;          /* Primary text */
  --color-text-muted: #6b7280;    /* Secondary text */
}
```

**Typography**:
```css
:root {
  --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
  --font-mono: 'SF Mono', 'Monaco', 'Courier New', monospace;

  --font-size-sm: 0.875rem;
  --font-size-base: 1rem;
  --font-size-lg: 1.125rem;
  --font-size-xl: 1.25rem;
}
```

**Spacing**:
```css
:root {
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 1rem;
  --spacing-lg: 1.5rem;
  --spacing-xl: 2rem;
}
```

---

### 9.3 Component-Specific Styles

**PromptCard**:
```css
.prompt-card {
  background: var(--color-bg-secondary);
  border: 1px solid var(--color-border);
  border-radius: 8px;
  padding: 1.25rem;
  transition: box-shadow 0.2s ease;
}

.prompt-card:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.prompt-category {
  display: inline-block;
  padding: 0.25rem 0.75rem;
  border-radius: 12px;
  font-size: var(--font-size-sm);
  font-weight: 500;
}

.badge-global {
  background: #dbeafe;
  color: #1e40af;
}

.badge-position {
  background: #d1fae5;
  color: #065f46;
}

.badge-forecast {
  background: #fef3c7;
  color: #92400e;
}
```

**PromptEditor (Modal)**:
```css
.prompt-editor-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
}

.prompt-editor-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
}

.prompt-editor-panel {
  position: relative;
  background: var(--color-bg);
  border-radius: 12px;
  width: 90%;
  max-width: 800px;
  max-height: 90vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
}

.prompt-textarea {
  font-family: var(--font-mono);
  font-size: 0.9rem;
  line-height: 1.5;
  resize: vertical;
  min-height: 300px;
}

.variable-badge {
  display: inline-block;
  background: #fef3c7;
  color: #92400e;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-family: var(--font-mono);
  font-size: 0.85rem;
  margin-right: 0.5rem;
}
```

---

## 10. Performance Considerations

### 10.1 Optimizations

**Memoization**:
```typescript
// Memoize filtered prompts to avoid re-computing on every render
const filteredPrompts = useMemo(() => {
  return prompts.filter(/* ... */)
}, [prompts, searchQuery, categoryFilter])

// Memoize expensive computations
const highlightedVariables = useMemo(() => {
  return detectVariables(promptText)
}, [promptText])
```

**Debounced Search**:
```typescript
import { useDebouncedValue } from '../hooks/useDebouncedValue'

const [searchInput, setSearchInput] = useState('')
const debouncedSearch = useDebouncedValue(searchInput, 300)

// Use debouncedSearch for filtering
const filteredPrompts = useMemo(() => {
  return prompts.filter(p =>
    p.name.toLowerCase().includes(debouncedSearch.toLowerCase())
  )
}, [prompts, debouncedSearch])
```

**Lazy Loading** (future enhancement):
```typescript
// For large lists (>100 prompts), implement virtual scrolling
// Use react-window or react-virtual
```

---

### 10.2 Bundle Size

**Expected Component Size**:
- PromptsManager: ~10 KB
- PromptEditor: ~8 KB
- PromptVersionHistory: ~6 KB
- Supporting components: ~5 KB
- **Total**: ~29 KB (minified, not gzipped)

**No new dependencies needed** (use existing):
- axios (already in project)
- lucide-react (already in project)
- react-toastify (already in project)

---

## 11. Accessibility (a11y) Requirements

### 11.1 Keyboard Navigation

**Requirements**:
- All interactive elements must be keyboard accessible
- Tab order must be logical
- Escape key closes modals
- Enter key saves forms (when valid)
- Arrow keys navigate timeline (bonus)

**Implementation**:
```typescript
// Modal escape key handler
useEffect(() => {
  const handleEscape = (e: KeyboardEvent) => {
    if (e.key === 'Escape') {
      onClose()
    }
  }

  window.addEventListener('keydown', handleEscape)
  return () => window.removeEventListener('keydown', handleEscape)
}, [onClose])

// Form enter key handler
const handleKeyDown = (e: React.KeyboardEvent) => {
  if (e.key === 'Enter' && e.metaKey) {
    // Cmd+Enter or Ctrl+Enter to save
    handleSavePrompt()
  }
}
```

---

### 11.2 ARIA Attributes

**Modal**:
```typescript
<div
  className="prompt-editor-modal"
  role="dialog"
  aria-modal="true"
  aria-labelledby="prompt-editor-title"
>
  <h2 id="prompt-editor-title">Edit Prompt</h2>
  {/* ... */}
</div>
```

**Form Errors**:
```typescript
<input
  id="prompt-name"
  aria-invalid={!!errors.name}
  aria-describedby={errors.name ? 'prompt-name-error' : undefined}
/>
{errors.name && (
  <span id="prompt-name-error" role="alert">
    {errors.name}
  </span>
)}
```

**Loading States**:
```typescript
<div role="status" aria-live="polite">
  {loading ? 'Loading prompts...' : `${prompts.length} prompts loaded`}
</div>
```

---

### 11.3 Screen Reader Support

**Requirements**:
- All images/icons have alt text or aria-label
- Form fields have associated labels
- Error messages are announced
- Success feedback is announced

**Implementation**:
```typescript
// Icon buttons
<button
  onClick={handleDelete}
  aria-label="Delete prompt"
>
  <Trash2 size={16} aria-hidden="true" />
</button>

// Success toast (react-toastify handles aria-live)
toast.success('Prompt saved successfully!')
```

---

## 12. File Structure

### 12.1 New Files to Create

```
frontend/src/
├── components/
│   ├── PromptsManager.tsx              # Container component
│   ├── PromptsManager.css
│   ├── PromptsManager.test.tsx
│   │
│   ├── PromptsList.tsx                 # List view
│   ├── PromptsList.css
│   ├── PromptsList.test.tsx
│   │
│   ├── PromptCard.tsx                  # Card component
│   ├── PromptCard.css
│   ├── PromptCard.test.tsx
│   │
│   ├── PromptEditor.tsx                # Editor modal
│   ├── PromptEditor.css
│   ├── PromptEditor.test.tsx
│   │
│   ├── PromptVersionHistory.tsx        # Version history (Story F9.4-002)
│   ├── PromptVersionHistory.css
│   └── PromptVersionHistory.test.tsx
│
├── services/
│   └── promptService.ts                # API client
│
├── types/
│   └── prompt.types.ts                 # TypeScript interfaces
│
└── hooks/
    └── useDebouncedValue.ts            # Utility hook (if not exists)
```

### 12.2 Modified Files

```
frontend/src/
└── components/
    └── SettingsCategoryPanel.tsx       # Add PromptsManager integration
```

---

## 13. Implementation Roadmap

### 13.1 Story F9.4-001: Prompts Settings Tab (5 pts)

**Phase 1: Setup (1-2 hours)**
- [ ] Create TypeScript types (`prompt.types.ts`)
- [ ] Create API service (`promptService.ts`)
- [ ] Modify `SettingsCategoryPanel.tsx` to detect "prompts" category

**Phase 2: List View (2-3 hours)**
- [ ] Create `PromptsManager.tsx` (container)
- [ ] Create `PromptsList.tsx` (list display)
- [ ] Create `PromptCard.tsx` (individual card)
- [ ] Implement search and category filter
- [ ] Add loading/error states
- [ ] Write unit tests for list components

**Phase 3: Editor (3-4 hours)**
- [ ] Create `PromptEditor.tsx` (modal)
- [ ] Implement form with validation
- [ ] Add variable detection logic
- [ ] Add template variables manager
- [ ] Implement test template functionality
- [ ] Write unit tests for editor

**Phase 4: CRUD Operations (2-3 hours)**
- [ ] Implement create prompt
- [ ] Implement edit prompt
- [ ] Implement delete prompt (soft delete)
- [ ] Add toast notifications
- [ ] Handle API errors gracefully
- [ ] Write integration tests

**Phase 5: Polish (1-2 hours)**
- [ ] Add CSS styling
- [ ] Ensure responsive design
- [ ] Add accessibility attributes
- [ ] Manual testing across browsers
- [ ] Code review and refactoring

**Total Estimated Time**: 9-14 hours

---

### 13.2 Story F9.4-002: Prompt Version History (3 pts)

**Phase 1: Version History Viewer (2-3 hours)**
- [ ] Create `PromptVersionHistory.tsx`
- [ ] Fetch version history from API
- [ ] Display timeline of versions
- [ ] Show version details on selection
- [ ] Write unit tests

**Phase 2: Restore Functionality (1-2 hours)**
- [ ] Implement restore version API call
- [ ] Add confirmation dialog
- [ ] Handle success/error states
- [ ] Update UI after restoration
- [ ] Write unit tests

**Phase 3: Diff Viewer (Optional, 2-3 hours)**
- [ ] Add diff library (e.g., `diff` or `react-diff-viewer`)
- [ ] Implement side-by-side comparison
- [ ] Highlight changes
- [ ] Add "Compare" button

**Phase 4: Polish (1 hour)**
- [ ] CSS styling
- [ ] Accessibility
- [ ] Manual testing

**Total Estimated Time**: 4-6 hours (without diff), 6-9 hours (with diff)

---

## 14. Risks & Mitigation

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **Backend API changes** | High | Low | API is from Epic 8 (already complete), unlikely to change |
| **Complex variable highlighting** | Medium | Medium | Start with simple regex detection, enhance later |
| **Large prompt templates** | Medium | Low | Use textarea with scroll, no height limit |
| **Concurrent edits** | Medium | Low | Document as known limitation, add version checking later |
| **Testing coverage** | High | Medium | Write tests alongside code (TDD), aim for 85%+ |
| **Modal accessibility** | Medium | Medium | Use proper ARIA, test with screen reader |
| **Mobile responsiveness** | Medium | Low | Use existing Settings responsive patterns |

---

## 15. Future Enhancements (Out of Scope)

### 15.1 Not in F9.4, but Possible Later

1. **Prompt Templates Library**
   - Pre-built prompt templates
   - Import/export prompts as JSON
   - Share prompts between users

2. **Advanced Diff Viewer**
   - Inline diff view
   - Word-level highlighting
   - Three-way merge (base, current, restored)

3. **Prompt Testing with Live Data**
   - Actually call Claude API with test data
   - Show generated response
   - Compare responses from different versions

4. **Prompt Analytics**
   - Track which prompts are used most
   - Show average response quality
   - Performance metrics

5. **Collaboration Features**
   - Comments on prompts
   - Approval workflow
   - Change requests

6. **Version Branching**
   - Create experimental versions
   - A/B testing
   - Merge branches

---

## 16. Acceptance Criteria Verification

### 16.1 Story F9.4-001 Checklist

**From Epic Document**:
- **Given** I navigate to AI Settings tab
  - ✅ SettingsCategoryPanel detects "prompts" category
  - ✅ PromptsManager renders

- **When** the page loads
  - ✅ PromptsManager fetches prompts from API
  - ✅ PromptsList displays all prompts
  - ✅ Loading spinner shown during fetch
  - ✅ Error message shown if fetch fails

- **Then** I see a list of all prompts
  - ✅ PromptCard components rendered for each prompt
  - ✅ Prompts show name, category, preview, version
  - ✅ Active/inactive status visible

- **And** I can click to edit a prompt
  - ✅ Edit button on each PromptCard
  - ✅ Clicking edit opens PromptEditor modal
  - ✅ Editor pre-fills with existing data

- **And** I can create new prompts
  - ✅ "Create Prompt" button in header
  - ✅ Clicking opens PromptEditor with empty form
  - ✅ Save creates new prompt via POST API

- **And** I see prompt variables highlighted
  - ✅ PromptEditor detects {{variable}} syntax
  - ✅ Variables highlighted in hint panel
  - ✅ Variables added to templateVariables automatically

- **And** I can test prompts before saving
  - ✅ "Test Template" button in editor
  - ✅ Validates variable definitions
  - ✅ Shows success/error feedback

---

### 16.2 Story F9.4-002 Checklist

**From Epic Document**:
- **Given** I'm viewing a prompt
  - ✅ PromptCard shows "History" button

- **When** I click "History"
  - ✅ PromptVersionHistory modal opens
  - ✅ Fetches versions from API
  - ✅ Displays loading spinner

- **Then** I see all previous versions
  - ✅ Timeline shows version list
  - ✅ Each version shows number, date, changed_by, reason

- **And** I can compare versions side-by-side
  - ✅ Clicking version shows details panel
  - ✅ Full prompt text displayed
  - ⚠️ Diff comparison (optional for MVP)

- **And** I can restore a previous version
  - ✅ "Restore This Version" button
  - ✅ Confirmation dialog
  - ✅ POST /api/prompts/{id}/restore/{version}
  - ✅ Success feedback

- **And** I see who made changes and when
  - ✅ changed_by field displayed
  - ✅ changed_at timestamp formatted
  - ✅ change_reason shown if provided

---

## 17. Definition of Done

### 17.1 Code Completeness

- [ ] All components implemented as per spec
- [ ] TypeScript types defined and used
- [ ] API service created and integrated
- [ ] All acceptance criteria met
- [ ] No TypeScript errors
- [ ] No ESLint warnings (or justified exceptions)

---

### 17.2 Testing

- [ ] Unit tests written for all components (85%+ coverage)
- [ ] Integration tests for CRUD flows
- [ ] All tests passing
- [ ] Manual testing completed
- [ ] Accessibility tested (keyboard, screen reader)
- [ ] Responsive design tested (mobile, tablet, desktop)

---

### 17.3 Documentation

- [ ] Code comments for complex logic
- [ ] JSDoc for public functions
- [ ] README updated if needed
- [ ] STORIES.md updated with progress
- [ ] Epic file updated with completion status

---

### 17.4 Code Review

- [ ] PR created with descriptive title
- [ ] PR description explains changes
- [ ] Screenshots/GIFs included
- [ ] Code reviewed by team
- [ ] All review comments addressed
- [ ] Approved by at least one reviewer

---

### 17.5 Deployment

- [ ] Merged to main branch
- [ ] No regressions in existing features
- [ ] Feature available in production
- [ ] User documentation updated (if needed)

---

## 18. Open Questions for FX

### 18.1 Design Decisions Needed

1. **Diff Viewer Complexity**
   - Q: Do we need side-by-side diff in MVP, or is showing full text of each version sufficient?
   - Recommendation: Start with full text view, add diff in follow-up story

2. **Prompt Testing Scope**
   - Q: Should "Test Prompt" actually call Claude API, or just validate syntax?
   - Recommendation: Start with syntax validation only, API testing is complex

3. **Inactive Prompts**
   - Q: Should deleted (inactive) prompts be shown anywhere, or hidden completely?
   - Recommendation: Hidden by default, add "Show Inactive" toggle later if needed

4. **Permission Model**
   - Q: Can all users edit all prompts, or should there be ownership/permissions?
   - Recommendation: All users can edit for MVP, add permissions later if needed

5. **Mobile Experience**
   - Q: Should PromptEditor be full-screen on mobile, or remain modal?
   - Recommendation: Full-screen on mobile (<768px), modal on desktop

---

## 19. Success Metrics

### 19.1 Development Metrics

- Story points: 8 total (5 for F9.4-001, 3 for F9.4-002)
- Test coverage: >85%
- No P0/P1 bugs in production
- Code review approval rate: 100%

---

### 19.2 User Experience Metrics

- Time to create prompt: <2 minutes
- Time to edit prompt: <1 minute
- Zero data loss incidents
- Positive user feedback on UX

---

## 20. Conclusion

This design document provides a comprehensive architecture for integrating Prompt Management into the Settings UI. The component hierarchy follows existing Settings patterns, ensures maintainability, and provides a solid foundation for future enhancements.

**Key Strengths**:
- ✅ Consistent with existing Settings architecture
- ✅ Reusable components with clear responsibilities
- ✅ Comprehensive error handling and edge case coverage
- ✅ Strong focus on accessibility and user experience
- ✅ Well-defined API integration points
- ✅ Detailed testing strategy

**Next Steps**:
1. Review and approve this design document
2. Begin implementation of Story F9.4-001
3. Create components following TDD approach
4. Regular check-ins during development
5. Demo completed feature before marking story complete

---

**Document Status**: ✅ Design Complete - Ready for Implementation

**Prepared By**: Claude Code
**Reviewed By**: [Pending - FX]
**Approved By**: [Pending - FX]
**Date**: 2025-11-05
